ğŸ¯ ğ—°ğ—¼ğ—¼ğ—¹ ğ—³ğ—²ğ—®ğ˜ğ˜‚ğ—¿ğ—²ğ˜€ ğ—¶ğ—» ğ—ğ——ğ— ğŸ®ğŸ¯ ğ—²ğ—»ğ—µğ—®ğ—»ğ—°ğ—¶ğ—»ğ—´ ğ—±ğ—²ğ˜ƒğ—²ğ—¹ğ—¼ğ—½ğ—²ğ—¿ ğ—²ğ˜…ğ—½ğ—²ğ—¿ğ—¶ğ—²ğ—»ğ—°ğ—² & ğ—½ğ—¿ğ—¼ğ—±ğ˜‚ğ—°ğ˜ğ—¶ğ˜ƒğ—¶ğ˜ğ˜†

ğ—ğ—®ğ˜ƒğ—® ğŸ®ğŸ¯ reached ğ˜ğ˜¦ğ˜¯ğ˜¦ğ˜³ğ˜¢ğ˜­ ğ˜ˆğ˜·ğ˜¢ğ˜ªğ˜­ğ˜¢ğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º on 17th Sept, 2024 & shipped a truckload of features. While there are numerous enhancements added to the JDK, let's focus on the JEPs included from ğ˜—ğ˜³ğ˜°ğ˜«ğ˜¦ğ˜¤ğ˜µ ğ˜ˆğ˜®ğ˜£ğ˜¦ğ˜³.


ğ—ğ—˜ğ—£ ğŸ°ğŸ³ğŸ³: ğ—œğ—ºğ—½ğ—¹ğ—¶ğ—°ğ—¶ğ˜ğ—¹ğ˜† ğ—±ğ—²ğ—°ğ—¹ğ—®ğ—¿ğ—²ğ—± ğ—°ğ—¹ğ—®ğ˜€ğ˜€ğ—²ğ˜€ & ğ—¶ğ—»ğ˜€ğ˜ğ—®ğ—»ğ—°ğ—² ğ—ºğ—®ğ—¶ğ—» ğ—ºğ—²ğ˜ğ—µğ—¼ğ—±ğ˜€

I remember well having a hard time dealing with the notoriously verbose syntax of writing just a basic "Hello World!" program the first time. It forced to grasp concepts which weren't even required on day-1. The public/private access modifier & their role in encapsulating units of code, the String[] args parameter that allows the user to pass arguments, the static modifier & how it's part of Java's class-and-object model. All this was hard to reason, especially to the beginners.

The motivation for this JEP is to help programmers that are new to Java by introducing concepts in the right order, starting with the more fundamental ones. 
This is done by:-
â€¢ Hiding any unnecessary details until they are useful in larger programs
â€¢ The launch protocol allowing instance main methods, non-static & don't need a public modifier, nor a String[] parameter
â€¢ Implicitly declared classes, automatically import useful methods for textual input & output, thereby avoiding the mysterious System.out.println.


ğ—ğ—˜ğ—£ ğŸ°ğŸ³ğŸ²: ğ— ğ—¼ğ—±ğ˜‚ğ—¹ğ—² ğ—œğ—ºğ—½ğ—¼ğ—¿ğ˜ ğ——ğ—²ğ—°ğ—¹ğ—®ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ˜€

More often than not, our classes are loaded up with a lot of import statements where the imports take up just as much space as the code itself. Many teams prefer single-type imports, however, in early-stage situations (when trying out a new feature, or in JShell) a more convenient approach could come in handy.

This JEP introduces module import declarations, and they have the form ğ˜ªğ˜®ğ˜±ğ˜°ğ˜³ğ˜µ ğ˜®ğ˜°ğ˜¥ğ˜¶ğ˜­ğ˜¦ ğ˜”;.

A module import declaration imports all of the public top-level classes and interfaces in the packages exported by the ğ˜®ğ˜°ğ˜¥ğ˜¶ğ˜­ğ˜¦ ğ˜” to the current module. Any indirect exports by the module M will also be made available by a module import declaration.

For example, if you write ğ˜ªğ˜®ğ˜±ğ˜°ğ˜³ğ˜µ ğ˜®ğ˜°ğ˜¥ğ˜¶ğ˜­ğ˜¦ ğ˜«ğ˜¢ğ˜·ğ˜¢.ğ˜´ğ˜²ğ˜­, it means your class will be able to read classes and interfaces from the packages ğ˜«ğ˜¢ğ˜·ğ˜¢.ğ˜´ğ˜²ğ˜­ ğ˜¢ğ˜¯ğ˜¥ ğ˜«ğ˜¢ğ˜·ğ˜¢ğ˜¹.ğ˜´ğ˜²ğ˜­ (because they are exported by the module java.sql). On top of that, because java.sql pulls in three other modules transitively, any exported packages from those modules will also be available.


ğ—ğ—˜ğ—£ ğŸ°ğŸ±ğŸ±: ğ—£ğ—¿ğ—¶ğ—ºğ—¶ğ˜ğ—¶ğ˜ƒğ—² ğ˜ğ˜†ğ—½ğ—²ğ˜€ ğ—¶ğ—» ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€, ğ—¶ğ—»ğ˜€ğ˜ğ—®ğ—»ğ—°ğ—²ğ—¢ğ—³ ğ—®ğ—»ğ—± ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ

This JEP proposes to support primitive types in all pattern contexts, & to extend instanceof & switch to work with all primitive types. The switch statement/expression now supports byte, short, char, int, boolean, float, double & long.

hashtag#java hashtag#jdk23 hashtag#ProjectAmber
