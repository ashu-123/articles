ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—¶ğ—»ğ—´ ğ—¥ğ—²ğ˜€ğ—¶ğ—¹ğ—¶ğ—²ğ—»ğ˜ ğ— ğ—¶ğ—°ğ—¿ğ—¼ğ˜€ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—²ğ˜€: ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€ & ğ˜€ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ—¶ğ—²ğ˜€ ğ—³ğ—¼ğ—¿ ğ—³ğ—®ğ—¶ğ—¹ğ˜‚ğ—¿ğ—² ğ—¿ğ—²ğ—°ğ—¼ğ˜ƒğ—²ğ—¿ğ˜†

Software engineers always strive to build faultless services which are immune to failures but even a minor error could potentially take down an entire monolith single-handedly, rendering it unfunctional. Well, this risk is highly reduced by breaking a giant monolith into a set of loosely coupled services, popularly known as microservices. Yet, failures are inevitable. Thus, handling the partial failures, preventing failures to cascade down to other services, recovering from failures & keeping the app functional even in minor breakages becomes key to a sustainable & performant design.

Let's dissect how can we introduce resiliency in such a distributed architecture, ensuring the system doesn't collapse entirely.


ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—¥ğ—²ğ˜€ğ—¶ğ—¹ğ—¶ğ—²ğ—»ğ—°ğ˜†?

Resilience is the ability of a software system to recover from failures & continue to function correctly. Resiliency in services aim to minimize the impact, range & frequency of failures. Resilient systems strive to ensure ğ˜©ğ˜ªğ˜¨ğ˜© ğ˜¢ğ˜·ğ˜¢ğ˜ªğ˜­ğ˜¢ğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º & aim to restore functionality in the least time possible.


ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€ & ğ˜€ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ—¶ğ—²ğ˜€ ğ—³ğ—¼ğ—¿ ğ—¯ğ˜‚ğ—¶ğ—¹ğ—±ğ—¶ğ—»ğ—´ ğ—® ğ—¿ğ—²ğ˜€ğ—¶ğ—¹ğ—¶ğ—²ğ—»ğ˜ ğ—®ğ—¿ğ—°ğ—µğ—¶ğ˜ğ—²ğ—°ğ˜ğ˜‚ğ—¿ğ—²:

â€¢ ğ—–ğ—¶ğ—¿ğ—°ğ˜‚ğ—¶ğ˜ ğ—•ğ—¿ğ—²ğ—®ğ—¸ğ—²ğ—¿: A pattern modelled after an electric circuit breaker, circuit breakers in software help manage failure in inter-service communication. Upon monitoring enough remote service call failures or calls taking too long, the circuit breaker intercedes to stop the calls temporarily allowing the remote service to recover.

â€¢ ğ—™ğ—®ğ—¹ğ—¹ğ—¯ğ—®ğ—°ğ—¸ ğ—½ğ—¿ğ—¼ğ—°ğ—²ğ˜€ğ˜€ğ—¶ğ—»ğ—´: With the fallback pattern, when a remote service call fails, rather than generating an exception, the service consumer executes an alternative code path trying to carry out actions through other means, while the faulty remote service gains some time to return to normalcy.

â€¢ ğ—•ğ˜‚ğ—¹ğ—¸ğ—µğ—²ğ—®ğ—± ğ—½ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»: It's a strategy to isolate different parts of the system to contain failures. This level of isolation helps in preventing failures in one component spreading to another. We can break the calls to remote resources into segregated thread pools reducing the risk that a faulty remote might eat up all the computation resources of a client app.

â€¢ ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜-ğ˜€ğ—¶ğ—±ğ—² ğ—¹ğ—¼ğ—®ğ—± ğ—¯ğ—®ğ—¹ğ—®ğ—»ğ—°ğ—¶ğ—»ğ—´: Its a method in which distribution of network load is managed by the client by making a request to a service registry to obtain a list of available remote service instances. The client then uses a predefined algorithm to determine which service to call.


Ensuring resilience in microservices is key to maintaining high availability, performance & customer satisfaction. By implementing comprehensive failure recovery strategies, we can protect our systems against inevitable failures, minimizing their impact.



hashtag#microservices hashtag#softwarearchitecture hashtag#systemdesign
